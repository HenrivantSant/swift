<?php declare( strict_types=1 );

/*
 * This file is part of the Swift Framework
 *
 * (c) Henri van 't Sant <hello@henrivantsant.dev>
 *
 * For the full copyright and license information, please view the LICENSE file that was distributed with this source code.
 */

namespace Swift\DependencyInjection;

use Laminas\Code\Generator\ClassGenerator;
use Laminas\Code\Generator\DocBlockGenerator;
use Laminas\Code\Generator\FileGenerator;
use Laminas\Code\Generator\PropertyGenerator;
use Laminas\Code\Reflection\ClassReflection;
use Swift\DependencyInjection\Attributes\Autowire;
use Swift\FileSystem\FileSystem;
use Swift\Serializer\Json;
use Symfony\Component\DependencyInjection\Argument\RewindableGenerator;
use Symfony\Component\DependencyInjection\Dumper\PhpDumper;
use Symfony\Component\DependencyInjection\Container as SymfonyContainer;

#[Autowire]
class ContainerDumper {
    
    public function __construct(
        protected FileSystem $fileSystem,
    ) {
    }
    
    public function dump( string $location, Container $container ): void {
        $dumper = new PhpDumper( $container );
        $this->fileSystem->write( $location, $dumper->dump( [ 'class' => 'CachedContainer' ] ) );
        
        require_once INCLUDE_DIR . $location;
        
        $generator = ClassGenerator::fromReflection(
            new ClassReflection( \CachedContainer::class ),
        );
        
        $generator->addProperty(
            'tagsMapping',
            $this->generateTagsArray( $container ),
            PropertyGenerator::FLAG_PROTECTED,
        );
        
        $generator->addProperty(
            'aliasMapping',
            $this->generateAliasesArray( $container ),
            PropertyGenerator::FLAG_PROTECTED,
        );
        
        $generator->addProperty(
            'resourcePathsMapping',
            $container->getResourcePaths(),
            PropertyGenerator::FLAG_PROTECTED,
        );
        
        $generator->setDocBlock(
            DocBlockGenerator::fromArray(
                [
                    'shortDescription' => 'Swift cached container',
                    'longDescription'  => '',
                    'tags'             => [
                        [
                            'name'        => 'package',
                            'description' => 'Swift/DependencyInjection/Container',
                        ],
                        [
                            'name'        => 'copyright',
                            'description' => 'Henri van \'t Sant <hello@henrivantsant.dev>',
                        ],
                    ],
                ]
            ),
        );
        
        $generator->setName( 'CachedContainer' );
        $generator->addUse( RewindableGenerator::class );
        $generator->setExtendedClass( SymfonyContainer::class );
        $generator->removeConstant( 'RUNTIME_EXCEPTION_ON_INVALID_REFERENCE' );
        $generator->removeConstant( 'EXCEPTION_ON_INVALID_REFERENCE' );
        $generator->removeConstant( 'NULL_ON_INVALID_REFERENCE' );
        $generator->removeConstant( 'IGNORE_ON_INVALID_REFERENCE' );
        $generator->removeConstant( 'IGNORE_ON_UNINITIALIZED_REFERENCE' );
        $generator->setNamespaceName( null );
        
        $file = FileGenerator::fromArray(
            [
                'classes'  => [ $generator ],
                'docblock' => DocBlockGenerator::fromArray(
                    [
                        'shortDescription' => 'CachedContainer',
                        'longDescription'  => 'This file is automatically generated by Swift Framework',
                    ]
                ),
            ]
        );
        
        if ( ! $this->fileSystem->dirExists( '/var/cache/di' ) ) {
            $this->fileSystem->createDirectory( '/var/cache/di' );
        }
        $this->fileSystem->write( '/var/cache/di/container.php', $file->generate() );
    }
    
    private function generateTagsArray( Container $container ): array {
        $tags = [];
        
        foreach ( $container->findTags() as $tag ) {
            $tags[ $tag ] = $container->getServicesByTag( $tag );
        }
        
        return $tags;
    }
    
    private function generateAliasesArray( Container $container ): array {
        $aliases = [];
        
        foreach ( $container->getDefinitions() as $alias => $service ) {
            $aliases[ $alias ] = $service->getClass();
            foreach ( $service->getTags() as $tag => $arr ) {
                $aliases[ $tag ] = $service->getClass();
                if ( str_starts_with( $tag, 'alias:' ) ) {
                    $aliases[ str_replace( 'alias:', '', $tag ) ] = $service->getClass();
                }
            }
        }
        
        return $aliases;
    }
    
}